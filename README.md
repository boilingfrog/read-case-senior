# 《Golang高级编程》读书笔记
这是一个关于读书的练习记录，这本书的名字是《Golang高级编程》


作者的地址：https://github.com/chai2010/advanced-go-programming-book


## 汇编部分的学习


- 调试汇编的命令
```
go tool compile -S pkg-data.go
```

- 将调试的命令放到s文件中

```
go tool compile -S pkg-data.go >> pkg-data.s
```

Go汇编中提供了DATA命令用于初始化包变量，下面是DATA的语法：

```
DATA symbol+offset(SB)/width, val
```

其中symbol为变量在汇编中对应的标示符，offset是符号的开始地址的偏移量，width是初始化内存的宽度大小，value是要初始化的值。其中当前包里中GO语言定义的symbol，在汇编代码中对应.symbol，其中“.”中点符号为一个特殊的unicode符号。

下面例子是个简单的例子：

```
DATA ·Id+0(SB)/1,$0x37
DATA ·Id+1(SB)/1,$0x25
```
给ID变量初始化了进制的0x2537,对应十进制的9527（需要以美元符号$开头表示）

### 计算机结构

汇编语⾔是直⾯计算机的编程语⾔，因此理解计算机结构是掌握汇编语⾔的前提。当前流⾏的计算机
基本采⽤的是冯·诺伊曼计算机体系结构（在某些特殊领域还有哈佛体系架构）。冯·诺依曼结构也称为
普林斯顿结构，采⽤的是⼀种将程序指令和数据存储在⼀起的存储结构。冯·诺伊曼计算机中的指令和
数据存储器其实指的是计算机中的内存，然后在配合CPU处理器就组成了⼀个最简单的计算机了。


X86其实是是80X86的简称（后⾯三个字⺟），包括Intel 8086、80286、80386以及80486等指令集
合，因此其架构被称为x86架构。x86-64是AMD公司于1999年设计的x86架构的64位拓展，向后兼容
于16位及32位的x86架构。X86-64⽬前正式名称为AMD64，也就是Go语⾔中GOARCH环境变量指定
的AMD64。

#### 汇编中的伪寄存器

什么是寄存器？

寄存器（Register），是中央处理器内的其中组成部分。寄存器是有限存贮容量的高速存贮部件，它
们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器（IR）和程
序计数器。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器。

在计算机体系结构里，处理器中的寄存器是少量且速度快的计算机存储器，借由提供快速共同地访问数
值来加速计算机程序的运行：典型地说就是在已知时间点所作的之计算中间的数值。

寄存器是存储器层次结构中的最顶端，也是系统操作数据的最快速途径。寄存器通常都是以他们可以保
存的比特数量来估量，举例来说，一个8位寄存器或32位寄存器。寄存器现在都以寄存器数组的方式来
实现，但是他们也可能使用单独的触发器、高速的核心存储器、薄膜存储器
以及在数种机器上的其他方式来实现出来。

GO汇编为了简化汇编代码的编写，引入PC，FP，SP，SB四个伪寄存器。四个伪寄存器加其它的通
⽤寄存器就是Go汇编语⾔对CPU的重新抽象，该抽象的结构也适⽤于其它⾮X86类型的体系结构。

![Aaron Swartz](https://github.com/zhan-liz/read-case-senior/blob/master/asm/asm1.png?raw=true)

在AMD64环境中，伪PC寄存器其实是IP指令计数器寄存器的别名。伪FP寄存器对应的是函数的帧指针，
一般用来访问函数的参数和返回值。伪SP栈指针对应的是当前函数栈帧的底部（不包括参数和返
回值部分），⼀般⽤于定位局部变量。伪SP是⼀个⽐较特殊的寄存器，因为还存在⼀个同名的SP真寄
存器。真SP寄存器对应的是栈的顶部，⼀般⽤于定位调⽤其它函数的参数和返回值。

当需要区分位伪寄存器和真寄存器的时候只要记住一点：伪寄存器⼀般需要⼀个标识符和偏移量为前
缀，如果没有标识符前缀则是真寄存器。⽐如 (SP) 、 +8(SP) 没有标识符前缀为真SP寄存器，
⽽ a(SP) 、 b+8(SP) 有标识符为前缀表示伪寄存器。


通用的计算机指令可以分为数据传输指令，算术运算和逻辑运算指令，控制流指令和其他指令等几类。

几个基本的指令


| 名称 | 解释 | 
|:------:| :------: |
| ADD |加法| 
| SUB |减法| 
| MUL |乘法| 
| DIV |除法| 
| AND |逻辑与| 
| OR |逻辑或| 
| NOT |逻辑去反|


控制流指令有CMP、JMP-if-x、JMP、CALL、RET等指令。CMP指令⽤于两个操作数做减法，根据⽐
较结果设置状态寄存器的符号位和零位，可以⽤于有条件跳转的跳转条件。JMP-if-x是⼀组有条件跳转
指令，常⽤的有JL、JLZ、JE、JNE、JG、JGE等指令，对应⼩于、⼩于等于、等于、不等于、⼤于
和⼤于等于等条件时跳转。JMP指令则对应⽆条件跳转，将要跳转的地址设置到IP指令寄存器就实现
了跳转。⽽CALL和RET指令分别为调⽤函数和函数返回指令。

| 名称 | 解释 | 
|:------:| :------: |
| JMP |无条件跳转| 
| JMP-if-x |有条件跳转，JL、JLZ、JE、JNE、JG、JGE| 
| CALL |调用函数| 
| RET |函数返回| 

其它⽐较重要的指令有LEA、PUSH、POP等⼏个。其中LEA指令将标准参数格式中的内存地址加载到
寄存器（⽽不是加载内存位置的内容）。PUSH和POP分别是压栈和出栈指令，通⽤寄存器中的SP为
栈指针，栈是向低地址⽅向增⻓的。

| 名称 | 解释 | 
|:------:| :------: |
| LEA |取地址| 
| PUSH |压栈| 
| POP |出栈| 


## rpc了解

标准库的RPC默认采⽤Go语⾔特有的gob编码，因此从其它语⾔调⽤Go语⾔实现的RPC服务将⽐较困
难。在互联⽹的微服务时代，每个RPC以及服务的使⽤者都可能采⽤不同的编程语⾔，因此跨语⾔是
互联⽹时代RPC的⼀个⾸要条件。得益于RPC的框架设计，Go语⾔的RPC其实也是很容易实现跨语⾔
⽀持的。

## protobuf了解

Protobuf最基本的数据单元是message,是类似go语言中结构体的存在。

官方对于ProtoBuf的定义

protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。

Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。

你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏由旧数据结构编译的已部署程序。

## 灰度发布

中型的互联⽹公司往往有着以百万计的⽤户，⽽⼤型互联⽹公司的系统则可能要服务千万级甚⾄亿级
的⽤户需求。⼤型系统的请求流⼊往往是源源不断的，任何⻛吹草动，都⼀定会有最终⽤户感受得
到。例如你的系统在上线途中会拒绝⼀些上游过来的请求，⽽这时候依赖你的系统没有做任何容错，
那么这个错误就会⼀直向上抛出，直到触达最终⽤户。形成⼀次对⽤户切切实实的伤害。这种伤害可
能是在⽤户的APP上弹出⼀个让⽤户摸不着头脑的诡异字符串，⽤户只要刷新⼀下⻚⾯就可以忘记这
件事。但也可能会让正在⼼急如焚地和⼏万竞争对⼿同时抢夺秒杀商品的⽤户，因为代码上的⼩问
题，丧失掉了先发优势，与⾃⼰蹲了⼏个⽉的⼼仪产品失之交臂。对⽤户的伤害有多⼤，取决于你的
系统对于你的⽤户来说有多重要。

不管怎么说，在⼤型系统中容错是重要的，能够让系统按百分⽐，分批次到达最终⽤户，也是很重要
的。虽然当今的互联⽹公司系统，名义上会说⾃⼰上线前都经过了充分慎重严格的测试，但就算它们
真得做到了，代码的bug总是在所难免的。即使代码没有bug，分布式服务之间的协作也是可能出现“逻
辑”上的⾮技术问题的。

这时候，灰度发布就显得⾮常重要了，灰度发布也称为⾦丝雀发布，传说17世纪的英国矿井⼯⼈发现
⾦丝雀对瓦斯⽓体⾮常敏感，瓦斯达到⼀定浓度时，⾦丝雀即会死亡，但⾦丝雀的致死量瓦斯对⼈并
不致死，因此⾦丝雀被⽤来当成他们的瓦斯检测⼯具。互联⽹系统的灰度发布⼀般通过两种⽅式实
现：

1 通过分批次部署实现灰度发布
2 通过业务规则进行灰度发布

对旧的系统进行升级迭代时，第一种用的比较多。新功能上线时，第二种用的比较多。当然，对比较重要的
老功能进行较大幅度的修改时，一般也会选择按业务规则进行发布，因为直接全量开放给所有的用户风险太大。


### 通过分批次部署实现灰度发布

例如部署在15个实例上，可以把实例分成四组，按照顺序，分别1-2-4-8，保证每次扩展时，大概都是二倍的关系。

![Aaron Swartz](https://github.com/zhan-liz/read-case-senior/blob/master/img/huidu.png?raw=true)








